#!/bin/bash
#
# ZClassic Snapshot Packaging Script
# Creates 50MB chunks from blockchain data with SHA256 manifest
#

set -e

# Configuration
SOURCE_DIR="/home/olivia/github/zclassic/old-zcl-block-data-snap"
OUTPUT_DIR="/home/olivia/github/zclassic/snapshot-output"
CHUNK_SIZE=$((50 * 1024 * 1024))  # 50MB in bytes
BLOCK_HEIGHT=2879438
TIMESTAMP=$(date +%s)

echo "ZClassic Snapshot Packaging Script"
echo "==================================="
echo "Source: $SOURCE_DIR"
echo "Output: $OUTPUT_DIR"
echo "Chunk size: 50MB"
echo "Block height: $BLOCK_HEIGHT"
echo ""

# Verify source directories exist
if [ ! -d "$SOURCE_DIR/chainstate" ]; then
    echo "ERROR: chainstate directory not found"
    exit 1
fi

if [ ! -d "$SOURCE_DIR/blocks" ]; then
    echo "ERROR: blocks directory not found"
    exit 1
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Step 1: Create tarball
echo "[1/4] Creating tarball from chainstate and blocks..."
TARBALL="$OUTPUT_DIR/snapshot-temp.tar.gz"

# CRITICAL: Only include public blockchain data - NO private data!
tar -czf "$TARBALL" \
    --exclude='wallet.dat' \
    --exclude='wallet.dat.*' \
    --exclude='wallet.dat.bak' \
    --exclude='wallet*.dat' \
    --exclude='peers.dat' \
    --exclude='peers.dat.old' \
    --exclude='debug.log' \
    --exclude='debug.log.old' \
    --exclude='db.log' \
    --exclude='.lock' \
    --exclude='*.lock' \
    --exclude='fee_estimates.dat' \
    --exclude='mempool.dat' \
    --exclude='banlist.dat' \
    --exclude='*.tmp' \
    --exclude='*.log' \
    -C "$SOURCE_DIR" \
    chainstate \
    blocks

TARBALL_SIZE=$(stat --format=%s "$TARBALL" 2>/dev/null || stat -f%z "$TARBALL")
echo "Tarball created: $TARBALL_SIZE bytes"

# Step 2: Split into chunks
echo "[2/4] Splitting into 50MB chunks..."
split -b $CHUNK_SIZE "$TARBALL" "$OUTPUT_DIR/chunk-"

# Rename chunks with proper numbering
CHUNK_NUM=0
for chunk in "$OUTPUT_DIR"/chunk-*; do
    if [ -f "$chunk" ]; then
        NEW_NAME=$(printf "$OUTPUT_DIR/chunk-%03d.dat" $CHUNK_NUM)
        mv "$chunk" "$NEW_NAME"
        CHUNK_SIZE_BYTES=$(stat --format=%s "$NEW_NAME" 2>/dev/null || stat -f%z "$NEW_NAME")
        echo "  Created: chunk-$(printf "%03d" $CHUNK_NUM).dat ($CHUNK_SIZE_BYTES bytes)"
        CHUNK_NUM=$((CHUNK_NUM + 1))
    fi
done

echo "Total chunks created: $CHUNK_NUM"

# Step 3: Calculate SHA256 for each chunk
echo "[3/4] Calculating SHA256 hashes..."
MANIFEST_FILE="$OUTPUT_DIR/manifest.txt"
MANIFEST_CPP="$OUTPUT_DIR/manifest.cpp"

echo "# ZClassic Snapshot Manifest" > "$MANIFEST_FILE"
echo "# Block Height: $BLOCK_HEIGHT" >> "$MANIFEST_FILE"
echo "# Timestamp: $TIMESTAMP" >> "$MANIFEST_FILE"
echo "# Total Chunks: $CHUNK_NUM" >> "$MANIFEST_FILE"
echo "# Chunk Size: 50MB" >> "$MANIFEST_FILE"
echo "#" >> "$MANIFEST_FILE"
echo "# Format: chunk_number|filename|sha256_hash|size_bytes" >> "$MANIFEST_FILE"
echo "" >> "$MANIFEST_FILE"

TOTAL_SIZE=0
for i in $(seq 0 $((CHUNK_NUM - 1))); do
    CHUNK_FILE=$(printf "$OUTPUT_DIR/chunk-%03d.dat" $i)
    CHUNK_SIZE=$(stat --format=%s "$CHUNK_FILE" 2>/dev/null || stat -f%z "$CHUNK_FILE")
    CHUNK_HASH=$(sha256sum "$CHUNK_FILE" | awk '{print $1}')

    echo "$i|chunk-$(printf "%03d" $i).dat|$CHUNK_HASH|$CHUNK_SIZE" >> "$MANIFEST_FILE"

    TOTAL_SIZE=$((TOTAL_SIZE + CHUNK_SIZE))

    if [ $((i % 10)) -eq 0 ]; then
        echo "  Processed chunk $i/$((CHUNK_NUM - 1))..."
    fi
done

echo "Total snapshot size: $TOTAL_SIZE bytes"

# Step 4: Generate C++ code for manifest
echo "[4/4] Generating C++ manifest code..."

cat > "$MANIFEST_CPP" << 'EOF'
// Auto-generated snapshot manifest
// DO NOT EDIT - Generated by create-snapshot.sh

CSnapshotManifest GetHardcodedManifest()
{
    CSnapshotManifest manifest;

EOF

echo "    manifest.nBlockHeight = $BLOCK_HEIGHT;" >> "$MANIFEST_CPP"
echo "    manifest.nTimestamp = ${TIMESTAMP}ULL;" >> "$MANIFEST_CPP"
echo "    manifest.nTotalSize = ${TOTAL_SIZE}ULL;" >> "$MANIFEST_CPP"
echo "" >> "$MANIFEST_CPP"

# Add each chunk to the manifest
while IFS='|' read -r num filename hash size; do
    if [[ ! "$num" =~ ^[0-9]+$ ]]; then
        continue  # Skip header lines
    fi

    echo "    manifest.vChunks.push_back(CSnapshotChunkInfo(" >> "$MANIFEST_CPP"
    echo "        $num," >> "$MANIFEST_CPP"
    echo "        uint256S(\"$hash\")," >> "$MANIFEST_CPP"
    echo "        ${size}ULL" >> "$MANIFEST_CPP"
    echo "    ));" >> "$MANIFEST_CPP"
    echo "" >> "$MANIFEST_CPP"
done < "$MANIFEST_FILE"

cat >> "$MANIFEST_CPP" << 'EOF'

    return manifest;
}
EOF

echo ""
echo "==================================="
echo "Snapshot packaging complete!"
echo ""
echo "Output files:"
echo "  - Chunks: $OUTPUT_DIR/chunk-*.dat ($CHUNK_NUM files)"
echo "  - Manifest: $OUTPUT_DIR/manifest.txt"
echo "  - C++ code: $OUTPUT_DIR/manifest.cpp"
echo ""
echo "Next steps:"
echo "  1. Review manifest.txt"
echo "  2. Copy manifest.cpp content to src/snapshot.cpp GetHardcodedManifest()"
echo "  3. Distribute chunks to nodes that will serve them"
echo ""
echo "Total size: $TOTAL_SIZE bytes"
echo "Chunk count: $CHUNK_NUM"
echo ""

# Cleanup temp tarball
rm -f "$TARBALL"
echo "Cleaned up temporary tarball"
